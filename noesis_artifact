<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NOESIS v2 - Interactive Field Dynamics Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Monaco', 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #00ff88;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #00ff88;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
            font-size: 2.5em;
        }
        
        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
            font-size: 0.9em;
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .panel {
            background: rgba(20, 20, 30, 0.9);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }
        
        .panel h2 {
            margin-bottom: 15px;
            color: #00ff88;
            font-size: 1.2em;
            border-bottom: 1px solid rgba(0, 255, 136, 0.2);
            padding-bottom: 5px;
        }
        
        canvas {
            width: 100%;
            height: 300px;
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.5);
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(135deg, #00ff88 0%, #00aa55 100%);
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            font-family: inherit;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .metric {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid rgba(0, 255, 136, 0.1);
        }
        
        .metric-label {
            color: #666;
            font-size: 0.8em;
            text-transform: uppercase;
        }
        
        .metric-value {
            color: #00ff88;
            font-size: 1.5em;
            font-weight: bold;
            margin-top: 5px;
        }
        
        .log {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 5px;
            padding: 10px;
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.85em;
            font-family: 'Monaco', monospace;
        }
        
        .log-entry {
            margin-bottom: 5px;
            color: #aaa;
        }
        
        .log-entry.success {
            color: #00ff88;
        }
        
        .log-entry.warning {
            color: #ffaa00;
        }
        
        .log-entry.info {
            color: #00aaff;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        
        .slider-container {
            margin: 15px 0;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        
        .field-viz {
            position: relative;
            height: 400px;
            margin: 20px 0;
        }
        
        #fieldCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00ff88;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 0.8em;
            pointer-events: none;
            display: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>NOESIS v2</h1>
        <div class="subtitle">Triadic Field Dynamics with Energy Minimization â€¢ No LLM, No Billions of Tokens</div>
        <div class="subtitle" style="margin-top: 5px;">
            Created by Lucas Postma â€¢ 
            <a href="https://github.com/DataDyneSolutions/asps-noesis-core" target="_blank" style="color: #00ff88; text-decoration: none;">
                github.com/DataDyneSolutions/asps-noesis-core
            </a>
        </div>
        
        <div class="grid">
            <div class="panel">
                <h2>Field Dynamics F1</h2>
                <div class="field-viz">
                    <canvas id="fieldCanvas"></canvas>
                </div>
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-label">Energy</div>
                        <div class="metric-value" id="energy">0.000</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Î”E (Improvement)</div>
                        <div class="metric-value" id="deltaE">0.000</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Gate</div>
                        <div class="metric-value" id="gate">0.00</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Iterations</div>
                        <div class="metric-value" id="iterations">0</div>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h2>Mirror Field F2 & Memory</h2>
                <canvas id="mirrorCanvas"></canvas>
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-label">Memory Gamma</div>
                        <div class="metric-value" id="memGamma">0.85</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Retained Configs</div>
                        <div class="metric-value" id="retainedConfigs">0</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Best Energy</div>
                        <div class="metric-value" id="bestEnergy">âˆž</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Convergence</div>
                        <div class="metric-value" id="convergence">0%</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="panel">
            <h2>Control Panel</h2>
            <div class="controls">
                <button onclick="noesis.initialize()">Initialize Fields</button>
                <button onclick="noesis.step()">Single Step</button>
                <button onclick="noesis.run()">Run Refinement</button>
                <button onclick="noesis.stop()">Stop</button>
                <button onclick="noesis.reset()">Reset Memory</button>
                <button onclick="noesis.startMetaLearning()" style="background: linear-gradient(135deg, #ff00ff 0%, #aa00ff 100%);">ðŸ§¬ Meta-Learn</button>
                <button onclick="noesis.showEvolution()" style="background: linear-gradient(135deg, #ffaa00 0%, #ff5500 100%);">ðŸ“Š Show Evolution</button>
            </div>
            
            <div class="slider-container">
                <div class="slider-label">
                    <span>Mirror Descent Step (Î·)</span>
                    <span id="mdStepValue">0.20</span>
                </div>
                <input type="range" id="mdStep" min="0.01" max="0.5" step="0.01" value="0.20">
            </div>
            
            <div class="slider-container">
                <div class="slider-label">
                    <span>Number of Entities</span>
                    <span id="nEntitiesValue">4</span>
                </div>
                <input type="range" id="nEntities" min="2" max="8" step="1" value="4">
            </div>
            
            <div class="slider-container">
                <div class="slider-label">
                    <span>Number of Slots</span>
                    <span id="nSlotsValue">32</span>
                </div>
                <input type="range" id="nSlots" min="16" max="64" step="8" value="32">
            </div>
        </div>
        
        <div class="panel">
            <h2>System Log</h2>
            <div class="log" id="log"></div>
        </div>
        
        <div class="panel" id="evolutionPanel" style="display: none;">
            <h2>ðŸ§¬ Energy Functional Evolution</h2>
            <div class="subtitle" style="color: #ff00ff; margin-bottom: 15px;">
                System is discovering its own physics laws through coefficient mutation
            </div>
            <canvas id="evolutionCanvas" style="height: 200px;"></canvas>
            <div class="metrics">
                <div class="metric">
                    <div class="metric-label">Generations</div>
                    <div class="metric-value" id="generations">0</div>
                </div>
                <div class="metric">
                    <div class="metric-label">Best Fitness</div>
                    <div class="metric-value" id="bestFitness">0.000</div>
                </div>
                <div class="metric">
                    <div class="metric-label">Mutations Kept</div>
                    <div class="metric-value" id="mutationsKept">0</div>
                </div>
                <div class="metric">
                    <div class="metric-label">Discovery Rate</div>
                    <div class="metric-value" id="discoveryRate">0%</div>
                </div>
            </div>
            <div class="log" id="evolutionLog" style="max-height: 150px; margin-top: 10px;"></div>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>

    <script>
        // NOESIS Core Implementation
        class NOESIS {
            constructor() {
                this.nEntities = 4;
                this.nSlots = 32;
                this.nBasis = 8;
                this.dRelation = 4;
                
                // Field states
                this.P = null;  // Position field [E x S]
                this.R = null;  // Relation field [E x E x S x d]
                this.alpha = null;  // Affinity [E]
                
                // Memory
                this.P_mem = null;
                this.R_mem = null;
                this.alpha_mem = null;
                this.memoryConfigs = [];
                
                // Parameters
                this.mdStep = 0.20;
                this.momentum = 0.80;
                this.etaR = 0.10;
                this.etaA = 0.10;
                this.gateTau = 0.50;
                this.memGammaBase = 0.85;
                
                // Energy coefficients (these will evolve!)
                this.coefficients = {
                    tv: 1.0,          // TV smoothness weight
                    reciprocity: 0.1, // Relation reciprocity weight
                    affinity: 0.01,   // Alpha regularization weight
                    unity: 10.0,      // Unity constraint weight
                    leash: 0.5        // Entity coupling weight
                };
                
                // Meta-learning state
                this.metaLearning = false;
                this.generation = 0;
                this.mutationHistory = [];
                this.bestCoefficients = {...this.coefficients};
                this.bestMetaFitness = Infinity;
                this.mutationsKept = 0;
                this.mutationTemp = 0.1;
                
                // State
                this.running = false;
                this.iterations = 0;
                this.currentEnergy = Infinity;
                this.bestEnergy = Infinity;
                this.lastDeltaE = 0;
                
                // Visualization
                this.fieldCanvas = document.getElementById('fieldCanvas');
                this.mirrorCanvas = document.getElementById('mirrorCanvas');
                this.fieldCtx = this.fieldCanvas.getContext('2d');
                this.mirrorCtx = this.mirrorCanvas.getContext('2d');
                
                this.setupCanvas();
                this.setupControls();
                this.initialize();
            }
            
            setupCanvas() {
                const resize = () => {
                    this.fieldCanvas.width = this.fieldCanvas.offsetWidth;
                    this.fieldCanvas.height = this.fieldCanvas.offsetHeight;
                    this.mirrorCanvas.width = this.mirrorCanvas.offsetWidth;
                    this.mirrorCanvas.height = this.mirrorCanvas.offsetHeight;
                };
                resize();
                window.addEventListener('resize', resize);
            }
            
            setupControls() {
                document.getElementById('mdStep').addEventListener('input', (e) => {
                    this.mdStep = parseFloat(e.target.value);
                    document.getElementById('mdStepValue').textContent = e.target.value;
                });
                
                document.getElementById('nEntities').addEventListener('input', (e) => {
                    this.nEntities = parseInt(e.target.value);
                    document.getElementById('nEntitiesValue').textContent = e.target.value;
                    this.initialize();
                });
                
                document.getElementById('nSlots').addEventListener('input', (e) => {
                    this.nSlots = parseInt(e.target.value);
                    document.getElementById('nSlotsValue').textContent = e.target.value;
                    this.initialize();
                });
            }
            
            initialize() {
                this.iterations = 0;
                
                // Initialize P with Gaussian bumps (like ToyWorld)
                this.P = this.createGaussianField();
                
                // Initialize R (anti-symmetric relations)
                this.R = this.createRelationField();
                
                // Initialize alpha (affinities)
                this.alpha = new Array(this.nEntities).fill(0.7);
                
                // Initialize memory if needed
                if (!this.P_mem) {
                    this.P_mem = this.deepCopy(this.P);
                    this.R_mem = this.deepCopy(this.R);
                    this.alpha_mem = [...this.alpha];
                }
                
                this.currentEnergy = this.computeEnergy();
                this.updateDisplay();
                this.log('Fields initialized with synthetic ToyWorld data', 'success');
            }
            
            createGaussianField() {
                const field = [];
                const sigma = 0.02;
                
                for (let e = 0; e < this.nEntities; e++) {
                    const mu = 0.2 + Math.random() * 0.6;
                    const entityField = [];
                    
                    for (let s = 0; s < this.nSlots; s++) {
                        const x = s / (this.nSlots - 1);
                        const value = Math.exp(-Math.pow(x - mu, 2) / (2 * sigma * sigma));
                        entityField.push(value);
                    }
                    
                    // Normalize
                    const sum = entityField.reduce((a, b) => a + b, 0);
                    field.push(entityField.map(v => v / sum));
                }
                
                return field;
            }
            
            createRelationField() {
                const field = [];
                
                for (let i = 0; i < this.nEntities; i++) {
                    const entityRelations = [];
                    for (let j = 0; j < this.nEntities; j++) {
                        const slotRelations = [];
                        for (let s = 0; s < this.nSlots; s++) {
                            const dims = [];
                            for (let d = 0; d < this.dRelation; d++) {
                                // Anti-symmetric initialization
                                const value = (i < j) ? (Math.random() - 0.5) * 0.1 : 
                                            (i > j) ? -(Math.random() - 0.5) * 0.1 : 0;
                                dims.push(value);
                            }
                            slotRelations.push(dims);
                        }
                        entityRelations.push(slotRelations);
                    }
                    field.push(entityRelations);
                }
                
                return field;
            }
            
            computeEnergy() {
                let energy = 0;
                
                // TV smoothness term (with evolved coefficient)
                for (let e = 0; e < this.nEntities; e++) {
                    for (let s = 1; s < this.nSlots; s++) {
                        energy += Math.abs(this.P[e][s] - this.P[e][s-1]) * this.coefficients.tv;
                    }
                }
                
                // Reciprocity penalty for R (with evolved coefficient)
                for (let i = 0; i < this.nEntities; i++) {
                    for (let j = i + 1; j < this.nEntities; j++) {
                        for (let s = 0; s < this.nSlots; s++) {
                            for (let d = 0; d < this.dRelation; d++) {
                                const asymmetry = this.R[i][j][s][d] + this.R[j][i][s][d];
                                energy += asymmetry * asymmetry * this.coefficients.reciprocity;
                            }
                        }
                    }
                }
                
                // Affinity regularization (with evolved coefficient)
                for (let e = 0; e < this.nEntities; e++) {
                    energy += this.alpha[e] * this.alpha[e] * this.coefficients.affinity;
                }
                
                // Unity constraint (with evolved coefficient)
                for (let e = 0; e < this.nEntities; e++) {
                    const sum = this.P[e].reduce((a, b) => a + b, 0);
                    energy += Math.pow(sum - 1.0, 2) * this.coefficients.unity;
                }
                
                return energy;
            }
            
            // META-LEARNING: Evolve the energy functional itself
            startMetaLearning() {
                this.metaLearning = true;
                this.generation = 0;
                this.mutationHistory = [];
                document.getElementById('evolutionPanel').style.display = 'block';
                
                this.logEvolution('ðŸ§¬ META-LEARNING INITIATED: System will discover its own physics', 'success');
                this.logEvolution('Starting with baseline coefficients, will mutate and evolve...', 'info');
                
                this.metaLearnStep();
            }
            
            metaLearnStep() {
                if (!this.metaLearning) return;
                
                // Save current state
                const originalCoeffs = {...this.coefficients};
                const originalP = this.deepCopy(this.P);
                
                // Test current coefficients
                this.initialize();
                const baselineFitness = this.evaluateFitness();
                
                // Try mutation
                const mutatedCoeff = this.mutateCoefficients();
                this.initialize();
                const mutantFitness = this.evaluateFitness();
                
                // Selection: keep if better
                if (mutantFitness < baselineFitness) {
                    this.mutationsKept++;
                    this.bestMetaFitness = mutantFitness;
                    this.bestCoefficients = {...this.coefficients};
                    
                    this.logEvolution(
                        `âœ… Generation ${this.generation}: Mutation improved! ` +
                        `${Object.keys(mutatedCoeff)[0]} = ${Object.values(mutatedCoeff)[0].toFixed(3)} ` +
                        `(fitness: ${mutantFitness.toFixed(4)})`,
                        'success'
                    );
                    
                    // Decrease temperature (converge)
                    this.mutationTemp *= 0.99;
                } else {
                    // Revert
                    this.coefficients = originalCoeffs;
                    this.P = originalP;
                    
                    // Increase temperature (explore)
                    this.mutationTemp = Math.min(0.5, this.mutationTemp * 1.01);
                }
                
                this.generation++;
                this.updateEvolutionDisplay();
                
                // Continue evolution
                if (this.generation < 100 && this.metaLearning) {
                    setTimeout(() => this.metaLearnStep(), 50);
                } else {
                    this.logEvolution(
                        `ðŸŽ¯ META-LEARNING COMPLETE: Discovered optimal energy functional after ${this.generation} generations`,
                        'success'
                    );
                    this.logEvolution(
                        `Final coefficients: TV=${this.coefficients.tv.toFixed(3)}, ` +
                        `Recip=${this.coefficients.reciprocity.toFixed(3)}, ` +
                        `Unity=${this.coefficients.unity.toFixed(3)}`,
                        'info'
                    );
                    this.metaLearning = false;
                }
            }
            
            mutateCoefficients() {
                // Pick random coefficient to mutate
                const keys = Object.keys(this.coefficients);
                const key = keys[Math.floor(Math.random() * keys.length)];
                
                // Gaussian mutation with adaptive temperature
                const mutation = 1 + (Math.random() - 0.5) * this.mutationTemp;
                const oldValue = this.coefficients[key];
                this.coefficients[key] = Math.max(0.001, oldValue * mutation);
                
                // Track mutation
                this.mutationHistory.push({
                    generation: this.generation,
                    coefficient: key,
                    oldValue: oldValue,
                    newValue: this.coefficients[key],
                    fitness: null
                });
                
                return {[key]: this.coefficients[key]};
            }
            
            evaluateFitness() {
                // Run refinement for a fixed number of steps
                let totalImprovement = 0;
                let convergenceSpeed = 0;
                
                for (let i = 0; i < 20; i++) {
                    const energyBefore = this.computeEnergy();
                    this.step();
                    const energyAfter = this.computeEnergy();
                    const improvement = Math.max(0, energyBefore - energyAfter);
                    totalImprovement += improvement;
                    
                    // Bonus for fast convergence
                    if (improvement < 1e-6) {
                        convergenceSpeed += (20 - i);
                        break;
                    }
                }
                
                // Fitness = final energy - improvement bonus - convergence speed bonus
                const finalEnergy = this.computeEnergy();
                const fitness = finalEnergy - totalImprovement * 0.1 - convergenceSpeed * 0.01;
                
                return fitness;
            }
            
            showEvolution() {
                const panel = document.getElementById('evolutionPanel');
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
                this.drawEvolutionGraph();
            }
            
            updateEvolutionDisplay() {
                document.getElementById('generations').textContent = this.generation;
                document.getElementById('bestFitness').textContent = this.bestMetaFitness.toFixed(4);
                document.getElementById('mutationsKept').textContent = this.mutationsKept;
                const rate = this.generation > 0 ? (this.mutationsKept / this.generation * 100) : 0;
                document.getElementById('discoveryRate').textContent = rate.toFixed(1) + '%';
                
                this.drawEvolutionGraph();
            }
            
            drawEvolutionGraph() {
                const canvas = document.getElementById('evolutionCanvas');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const w = canvas.width = canvas.offsetWidth;
                const h = canvas.height = canvas.offsetHeight;
                
                ctx.clearRect(0, 0, w, h);
                
                // Draw coefficient evolution over time
                const coeffNames = Object.keys(this.coefficients);
                const colors = ['#ff00ff', '#00ffff', '#ffff00', '#ff8800', '#88ff00'];
                
                coeffNames.forEach((name, idx) => {
                    ctx.strokeStyle = colors[idx % colors.length];
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    // Get history for this coefficient
                    const history = this.mutationHistory.filter(m => m.coefficient === name);
                    if (history.length === 0) return;
                    
                    history.forEach((mut, i) => {
                        const x = (mut.generation / 100) * w;
                        const y = h - (mut.newValue / 20) * h; // Normalize to display
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    });
                    
                    ctx.stroke();
                    
                    // Label
                    ctx.fillStyle = colors[idx % colors.length];
                    ctx.font = '10px Monaco';
                    ctx.fillText(name, 10, 20 + idx * 15);
                });
                
                // Draw current generation line
                if (this.generation > 0) {
                    const x = (this.generation / 100) * w;
                    ctx.strokeStyle = 'rgba(0, 255, 136, 0.5)';
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            logEvolution(message, type = 'info') {
                const logEl = document.getElementById('evolutionLog');
                if (!logEl) return;
                
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                const timestamp = new Date().toLocaleTimeString();
                entry.textContent = `[${timestamp}] ${message}`;
                logEl.appendChild(entry);
                logEl.scrollTop = logEl.scrollHeight;
                
                // Keep only last 20 entries
                while (logEl.children.length > 20) {
                    logEl.removeChild(logEl.firstChild);
                }
            }
            
            step() {
                const energyBefore = this.currentEnergy;
                
                // Mirror descent on P
                for (let e = 0; e < this.nEntities; e++) {
                    const gradP = this.computeGradientP(e);
                    const newP = [];
                    let sumExp = 0;
                    
                    for (let s = 0; s < this.nSlots; s++) {
                        const logP = Math.log(this.P[e][s] + 1e-8) - this.mdStep * gradP[s];
                        const expP = Math.exp(logP);
                        newP.push(expP);
                        sumExp += expP;
                    }
                    
                    // Normalize (totality constraint)
                    this.P[e] = newP.map(p => p / sumExp);
                }
                
                // Momentum update on R (maintaining anti-symmetry)
                for (let i = 0; i < this.nEntities; i++) {
                    for (let j = i + 1; j < this.nEntities; j++) {
                        for (let s = 0; s < this.nSlots; s++) {
                            for (let d = 0; d < this.dRelation; d++) {
                                const grad = (this.R[i][j][s][d] + this.R[j][i][s][d]) * 0.2;
                                const update = this.etaR * grad;
                                this.R[i][j][s][d] -= update;
                                this.R[j][i][s][d] = -this.R[i][j][s][d];
                            }
                        }
                    }
                }
                
                // Update alpha
                for (let e = 0; e < this.nEntities; e++) {
                    const gradA = 2 * this.alpha[e] * 0.01;
                    this.alpha[e] -= this.etaA * gradA;
                    this.alpha[e] = Math.max(0.1, this.alpha[e]);
                }
                
                this.currentEnergy = this.computeEnergy();
                this.lastDeltaE = Math.max(0, energyBefore - this.currentEnergy);
                
                // Memory update with Î”E-gated retention
                this.updateMemory();
                
                this.iterations++;
                this.updateDisplay();
                
                if (this.currentEnergy < this.bestEnergy) {
                    this.bestEnergy = this.currentEnergy;
                    this.log(`New best energy: ${this.bestEnergy.toFixed(4)}`, 'success');
                }
            }
            
            computeGradientP(entity) {
                const grad = new Array(this.nSlots).fill(0);
                
                // TV gradient
                for (let s = 1; s < this.nSlots; s++) {
                    const diff = this.P[entity][s] - this.P[entity][s-1];
                    grad[s] += Math.sign(diff);
                    grad[s-1] -= Math.sign(diff);
                }
                
                // Unity constraint gradient
                const sum = this.P[entity].reduce((a, b) => a + b, 0);
                const unityGrad = 2 * (sum - 1.0) * 10;
                for (let s = 0; s < this.nSlots; s++) {
                    grad[s] += unityGrad;
                }
                
                return grad;
            }
            
            updateMemory() {
                const gate = this.lastDeltaE > 0.001 ? 1.0 : 0.0;
                const gamma = Math.min(0.999, this.memGammaBase + 0.1 * gate * (1 - Math.tanh(this.lastDeltaE)));
                
                // EMA update
                for (let e = 0; e < this.nEntities; e++) {
                    for (let s = 0; s < this.nSlots; s++) {
                        this.P_mem[e][s] = gamma * this.P_mem[e][s] + (1 - gamma) * this.P[e][s];
                    }
                }
                
                // Store good configurations
                if (this.lastDeltaE > 0.01 && this.memoryConfigs.length < 10) {
                    this.memoryConfigs.push({
                        P: this.deepCopy(this.P),
                        energy: this.currentEnergy,
                        iteration: this.iterations
                    });
                }
                
                document.getElementById('memGamma').textContent = gamma.toFixed(3);
                document.getElementById('retainedConfigs').textContent = this.memoryConfigs.length;
            }
            
            run() {
                this.running = true;
                this.log('Starting refinement loop', 'info');
                
                const runStep = () => {
                    if (!this.running) return;
                    
                    this.step();
                    
                    if (this.iterations < 100 && this.lastDeltaE > 1e-6) {
                        requestAnimationFrame(runStep);
                    } else {
                        this.running = false;
                        this.log(`Refinement complete. Final energy: ${this.currentEnergy.toFixed(4)}`, 'success');
                    }
                };
                
                runStep();
            }
            
            stop() {
                this.running = false;
                this.log('Refinement stopped', 'warning');
            }
            
            reset() {
                this.P_mem = null;
                this.R_mem = null;
                this.alpha_mem = null;
                this.memoryConfigs = [];
                this.bestEnergy = Infinity;
                this.initialize();
                this.log('Memory reset', 'info');
            }
            
            updateDisplay() {
                // Update metrics
                document.getElementById('energy').textContent = this.currentEnergy.toFixed(3);
                document.getElementById('deltaE').textContent = this.lastDeltaE.toFixed(4);
                document.getElementById('gate').textContent = (this.lastDeltaE > 0.001 ? 1.0 : 0.0).toFixed(2);
                document.getElementById('iterations').textContent = this.iterations;
                document.getElementById('bestEnergy').textContent = 
                    this.bestEnergy === Infinity ? 'âˆž' : this.bestEnergy.toFixed(3);
                
                const convergence = Math.min(100, (1 - Math.exp(-this.iterations / 20)) * 100);
                document.getElementById('convergence').textContent = convergence.toFixed(0) + '%';
                
                // Visualize fields
                this.drawField();
                this.drawMirrorField();
            }
            
            drawField() {
                const ctx = this.fieldCtx;
                const w = this.fieldCanvas.width;
                const h = this.fieldCanvas.height;
                
                ctx.clearRect(0, 0, w, h);
                
                const entityHeight = h / this.nEntities;
                const slotWidth = w / this.nSlots;
                
                for (let e = 0; e < this.nEntities; e++) {
                    const y = e * entityHeight;
                    
                    // Draw field distribution
                    ctx.beginPath();
                    ctx.strokeStyle = `hsl(${120 + e * 40}, 100%, 50%)`;
                    ctx.lineWidth = 2;
                    
                    for (let s = 0; s < this.nSlots; s++) {
                        const x = s * slotWidth;
                        const value = this.P[e][s];
                        const py = y + entityHeight - value * entityHeight * 0.8;
                        
                        if (s === 0) ctx.moveTo(x, py);
                        else ctx.lineTo(x, py);
                    }
                    ctx.stroke();
                    
                    // Fill under curve
                    ctx.lineTo(w, y + entityHeight);
                    ctx.lineTo(0, y + entityHeight);
                    ctx.closePath();
                    ctx.fillStyle = `hsla(${120 + e * 40}, 100%, 50%, 0.1)`;
                    ctx.fill();
                    
                    // Entity label
                    ctx.fillStyle = '#00ff88';
                    ctx.font = '12px Monaco';
                    ctx.fillText(`E${e} Î±=${this.alpha[e].toFixed(2)}`, 10, y + 20);
                }
            }
            
            drawMirrorField() {
                const ctx = this.mirrorCtx;
                const w = this.mirrorCanvas.width;
                const h = this.mirrorCanvas.height;
                
                ctx.clearRect(0, 0, w, h);
                
                // Compress to F2 (downsample)
                const S2 = Math.floor(this.nSlots / 4);
                const entityHeight = h / this.nEntities;
                const slotWidth = w / S2;
                
                for (let e = 0; e < this.nEntities; e++) {
                    const y = e * entityHeight;
                    
                    // Downsample P to P2
                    const P2 = [];
                    for (let s2 = 0; s2 < S2; s2++) {
                        const startIdx = Math.floor(s2 * this.nSlots / S2);
                        const endIdx = Math.floor((s2 + 1) * this.nSlots / S2);
                        let sum = 0;
                        for (let s = startIdx; s < endIdx; s++) {
                            sum += this.P[e][s];
                        }
                        P2.push(sum / (endIdx - startIdx));
                    }
                    
                    // Draw memory field
                    ctx.beginPath();
                    ctx.strokeStyle = `hsla(${120 + e * 40}, 50%, 40%, 0.5)`;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    
                    for (let s2 = 0; s2 < S2; s2++) {
                        const x = s2 * slotWidth;
                        const value = this.P_mem ? 
                            this.P_mem[e][Math.floor(s2 * this.nSlots / S2)] : 0;
                        const py = y + entityHeight - value * entityHeight * 0.8;
                        
                        if (s2 === 0) ctx.moveTo(x, py);
                        else ctx.lineTo(x, py);
                    }
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Draw compressed field
                    ctx.beginPath();
                    ctx.strokeStyle = `hsl(${120 + e * 40}, 100%, 70%)`;
                    ctx.lineWidth = 3;
                    
                    for (let s2 = 0; s2 < S2; s2++) {
                        const x = s2 * slotWidth;
                        const value = P2[s2];
                        const py = y + entityHeight - value * entityHeight * 0.8;
                        
                        if (s2 === 0) ctx.moveTo(x, py);
                        else ctx.lineTo(x, py);
                    }
                    ctx.stroke();
                    
                    // Label
                    ctx.fillStyle = '#00ff88';
                    ctx.font = '12px Monaco';
                    ctx.fillText(`F2[E${e}]`, 10, y + 20);
                }
                
                // Draw stored configurations as dots
                ctx.fillStyle = 'rgba(0, 255, 136, 0.3)';
                this.memoryConfigs.forEach((config, idx) => {
                    const x = (idx / 10) * w;
                    const y = h - 20;
                    ctx.beginPath();
                    ctx.arc(x + 10, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            log(message, type = 'info') {
                const logEl = document.getElementById('log');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                const timestamp = new Date().toLocaleTimeString();
                entry.textContent = `[${timestamp}] ${message}`;
                logEl.appendChild(entry);
                logEl.scrollTop = logEl.scrollHeight;
                
                // Keep only last 50 entries
                while (logEl.children.length > 50) {
                    logEl.removeChild(logEl.firstChild);
                }
            }
            
            deepCopy(obj) {
                return JSON.parse(JSON.stringify(obj));
            }
        }
        
        // Initialize NOESIS
        const noesis = new NOESIS();
        noesis.log('NOESIS v2 initialized - No LLM, No billions of tokens needed', 'success');
        noesis.log('Using synthetic ToyWorld data (infinite generation)', 'info');
        noesis.log('Core: Mirror descent on simplex, anti-symmetric relations, Î”E-gated memory', 'info');
    </script>
</body>
</html>
